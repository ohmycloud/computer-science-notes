原文链接: https://raku-advent.blog/2022/12/23/sigils-2/

# 错了

直到几天前，我还打算把这篇文章作为我正在开发的 Raku 持久化数据结构的更新。而且我还在这篇文章的末尾附上了一个（非常简短的）状态更新。但我注意到了一些更紧迫的事情。互联网上有人错了--而这个人就是我。

![img](https://xkcd.com/386/)

具体来说，在我前几天关于符号的帖子中，我明显错误地描述了 Raku 应用于符号变量的语义。而且--考虑到这篇文章是关于符号的，最后的三分之一集中在 Raku 的符号上，而那一部分大部分讨论的是这些符号的语义--对 Raku 符号的语义的错误并不完全是一个小错误。哎呀！"。

作为部分缓解，我要提到一件事：没有人指出我对相关语义的错误描述，尽管这篇文章引起了两百多条讨论，其中大部分是有思想的。现在，可能是没有人一直读到 7000 字的帖子的第三部分（一个可以理解的选择！）。但是，考虑到众所周知的在互联网上纠正人的流行，我认为没有任何纠正是一些证据，表明我的误解对其他人也不明显。事实上，当我在回复那篇文章的评论时，决定写一篇设计古怪的乐谱课来说明我所描述的语义时，我才发现这个问题；令我吃惊的是，它显示我把这些语义弄错了。

一方面，我显然很高兴我的帖子引起了一些人的共鸣。 我认识到，大多数读者对关于符号的表达能力的更大范围的问题感兴趣，而不是对 Raku 的语义细节感兴趣。另一方面，我突然意识到，我刚刚向一大批观众错误地解释了这些语义，至少可以说是一种有趣的经历--这诱使我以一种完全不同的方式来介绍这些 `$@%&` 的字符。

很明显，这需要一个后续的帖子，你现在正在阅读。

我这篇文章的目标是，首先，解释我在 Raku 的语义方面有什么错误，我是如何犯这个错误的，以及为什么我和其他人都没有注意到。然后，我们将转向一些关于语言设计的更广泛的教训，无论是在 Raku 还是在一般的编程语言中。 最后，在正确理解 Raku 语义的基础上，我们将重新评估 Raku 的符号，以及它们所提供的表达能力。

我做错了什么--我做对了什么

在那篇文章中，我说 `@` 符号只能用于实现位置（"类似数组"）角色的类型；`%` 符号只能用于实现关联（"类似哈希"）角色的类型；而 `&` 符号只能用于实现可调用（"类似函数"）角色的类型。所有这些都是对的（而且几乎是直接来自语言文档）。

我出错的地方在于我描述了一个类型为了实现这些角色而必须满足的要求。我把位置性角色描述为需要一个可迭代的、有序的集合，可以按位置进行索引（例如，用 `@foo[5]`）；我把关联性角色描述为需要一个可迭代的、无序的 Pair 集合，可以按关联进行索引（例如，用 `%foo<key>`）；我把可调用角色描述为需要一个类型支持作为一个函数被调用（例如，用 `&foo()`）。

然而，那是一种夸张的说法。实现这三个角色的要求实际上是：完全没有。没错，它们完全是"标记角色"，相当于 Rust 的标记特性的 Raku。

哦，当然，Raku 的文档提供了你应该实现的方法列表，但那些只是建议而已。绝对没有什么可以阻止我们编写关联性、位置性或可调用性的类，或者--为什么不呢？- 如果我们想的话，三者都可以。或者，就这一点而言，由于 Raku 支持运行时合成，下面的方法是完全有效的:

```raku
my @pos := 'foo' but Positional; 
my %asc := 90000 but Associative; 
my &cal := False but Callable;
```

是的，我们可以有一个位置字符串，一个关联数字，和一个可调用的布尔值。

我们怎么会错过这个呢？

那么，事情是这样的：我已经写了不少 Raku 的代码，当时我错误地认为这些角色有我所描述的类型约束--这比"完全没有"要严格得多。我不认为我是唯一这样做的人；事实上，我在上一篇文章中得到的最多的评论是对 `@` 和 `%` 没有被限制在具体的 Array 和 Hash 上感到惊讶/困惑（我以前也听说过这种看法）。我不认为我们中有人疯狂地想这些事情--当你刚开始使用 Raku 时，你看到的绝大多数（也许是全部）`@`-和 `%` 符号的东西都是 Array 和 Hash。我相信我从来没有在 Raku 中看到一个  `@`-sigiled 变量不是某种有序的集合。所以，也许人们认为类型约束更严格是有一定道理的。

但这反过来又引发了两个问题。首先，鉴于这些符号的无约束性，为什么我没有在野外看到一些位置字符串？毕竟，依靠程序员的纪律而不是工具的执行，通常是一个快速和痛苦的灾难的秘诀。其次，考虑到 `@`-和 `%`-符号的变量几乎总是满足更严格的类型约束，为什么 Raku 不执行一个？

良好的默认值>程序员的纪律

让我们依次解决这些问题。为什么我没有看到 `@`-sigiled 字符串或 `%`-sigiled 数字？因为 Raku 不是依靠程序员的纪律来防止这些事情；而是依靠程序员的懒惰--一种更强大的力量。编写写 `my @pos := 'foo' but Positional` 似乎非常容易，但它有三个不同的元素会劝阻一个 Raku 新手那样写：`:=` 绑定操作符（大多数程序员更熟悉赋值，而且 `=` 在 Raku 代码例子中绝大多数是更常见的）；`but` 操作符（运行时合成在更广泛的编程世界中相对不常见，而且它不是 Raku 代码经常使用的工具）和 Positional（一般来说，角色不是真正的 Raku 101 主题，而 Positional / Associative / Callable 更不是--毕竟，所有应该实现这些角色的内置类型已经这样了）。

让我们把这句话与一个Raku 新手更有可能编写的版本进行对比--事实上，每个 Raku 人都必须反复写的版本：`my @pos = 'foo'`。这句话消除了前面代码中所有三个语法上的障碍。更重要的是，它可以工作。因为 `@`-sigil 提供了一个默认的数组容器，这一行创建了数组 `['foo']` --这更有可能是用户首先想要的东西。

当然，这只是一个例子，但一般模式是成立的。Raku 很少禁止用户做一些事情（即使是像 Positionitional 字符串这样愚蠢的事情），但它同时也善于使默认/最简单的路径避免这些问题。如果有一个简单但不严格的选择，那么再多的"程序员纪律"也无法阻止每个人去选择。但是当更安全/更干净的东西也是迄今为止更容易的东西时，我们就不是在依靠程序员的纪律了。我们正在完全消除诱惑。

等到有人写了足够多的 Raku，以至于 `:=` , `but`, 和 `Positional` 不会让他们有任何停顿的时候，他们可能已经把"@意味着"类似数组，但也许不是数组"的概念根深蒂固，以至于他们不会考虑创建一个古怪的 `Positional` 类型，除非是真正的最后手段--我想我无意中说明了这一点。

更加严格

那我们之前提出的第二个问题呢？为什么 Raku 不执行更严格的类型约束？它当然可以。Raku 有足够的语言机制来真正地严格规定角色的要求。直接规定任何实现位置角色的类型必须同时实现位置索引的方法，这将是很简单的。而且，由于 Raku 已经有一个 Iterable 角色，要求 Positional 类型是可迭代的也是很简单的。那么为什么不呢？

嗯，因为--即使绝大多数的位置类型应该允许索引并且应该是可迭代的，也会有一些有充分的理由不允许索引。而 Raku 可以把 "为什么不？"的问题转过来问"为什么？"

提供保证与传达意图

所有这些都使一个问题成为焦点--这个问题直指 Raku 设计理念的核心，也是任何语言设计师需要考虑的重要问题。

这个问题是：你的语言是对提供保证更感兴趣还是对传达意图更感兴趣？这不是一个简单的问题，我也不认为有一个普遍的答案。

担保是伟大的

当我不写 Raku（或长篇博文）时，我花最多时间的编程语言是 Rust。而 Rust 在这个问题上非常坚定地站在提供担保的一边。它是真正的伟大。有 Rust 编译器和强大的静态类型系统作为后盾，有一种绝对令人难以置信的自由，因为你知道你绝对、100% 不需要担心某些类别的错误或误差。有了这个保证，你就可以把这些考虑从你的心理缓存中完全删除（你知道，为 Rust 中认知上复杂的东西腾出空间--这不是一个小小的清单）。所以，是的，我在最初写 Rust 的时候就看到了它的吸引力，而且每次我回到这个语言的时候都会再次看到它。

事实上，我认为 Rust 的保证是 100% 正确的选择--对 Rust 而言。我相信这些保证的力量非常适合 Rust 最初的用例（在 Firefox 上工作），也是 Facebook、微软、亚马逊和谷歌都接受 Rust 的巨大原因：当你在一个具有巨大开源项目或大科技公司范围的团队中合作时，保证变得更加有价值。当一些人离开，新的人加入，不再有办法让每个人站在同一起跑线上时，有一种语言说"你不必相信他们的代码，只要相信我"是很好的。

但关于保证的问题是，它们必须是绝对的。如果某件事情是 "90% 的保证"，那么它就不是保证，只是有可能。所以，这不是一个你一定能找到一个满意的平衡点的交易。

编码是一种协作性的、异步的交流方式

担保与交流是 Raku 做出另一种选择的一个交易，而且是以一种大的方式。Raku 对帮助程序员沟通他们的意图更感兴趣，而不是严格地执行规则以做出保证。如果 Rust 对代码的基本隐喻是演绎证明--每一步都取决于前一步的正确性，所以我们最好尽可能地确定它们是正确的--那么 Raku 的基本隐喻，毫不奇怪，是更加语言化的。Raku 对编码的隐喻是朋友之间的异步对话：也许是电子邮件交流，或者--最好是--一系列的信件。

写代码怎么会像给朋友发电子邮件？嗯，我们上次谈到了作者、读者和编译器之间的三方对话，但这有点简化了。大多数时候，我们同时在阅读以前写的代码和写额外的代码，这就把三方对话变成了四方对话。的确，"以前的作者"、"现在的读者/作者 "和 "未来的读者 "可能都是你，但你在自言自语的事实并没有使它成为一个对话：无论如何，目标是尽可能地理解以前作者的意思，决定你想在对话中加入什么，然后尽可能清楚地表达自己--但要遵守编译器也需要理解你的代码这一约束。

关于最后一点，我想说几句。从 "代码即证明 "的隐喻中，严格的编译器显然是一种胜利。对任何事物的正确性有信心已经很困难了，但当你增加可能性空间时，它就更难了。但从 "代码即交流 "的隐喻来看，编译器（或格式化器）有一个真正的缺点，它限制了你以多种方式表达同一事物的能力。如果你被要求穿统一的衣服，你穿什么衬衫就不再是一个表达的选择。同样，当只有一种方法可以做某事时，那么这样做就不能表达任何东西。但是，当有不止一种方法可以做的时候，突然就有理由问："好吧，但是他们为什么要这样做？"。这一点在 Raku 中得到了深刻的体现：有多种方法可以写出做同样事情的代码，但这些不同的方法并没有说同样的事情--它们允许你把重点放在不同的地方，这取决于你想把读者的注意力引向哪里。乐乐的大量 "词汇 "所起的作用与增加你在自然语言中的词汇量相同：它使你更容易挑选出恰到好处的词。

我担心这样的描述可能会使你想象乐库人对每一行代码苦苦思索，精心制作，使其具有理想的含义。根本不是这样的--记住，这个比喻是一封友好的电子邮件；而不是诗歌。有时候，把电子邮件中的关键句子写得恰到好处是值得的，但通常情况下，快速写完一封便条会更好。但是，即使在快速记录中，我们也面临着许多表达同一事物的方式，而最能表达我们意思的方式就是我们选择的方式--也许如此之快，以至于我们甚至没有注意到自己这样做。

当代码是交流的时候，规则变成了建议

当给朋友发电子邮件时，你们都不能制定对方必须遵守的 "规则"。你可以为他们为什么不应该做某事提出论据，你可以清楚明确地表达这样做是一个错误，但你不能阻止他们。你们是朋友--平等的--电子邮件的作者和读者都不能否决对方。

而 Raku 的情况也是如此。Raku 使一些代码的作者很难（经常是不可能）100% 地阻止别人以特定方式使用他们的代码。Raku 提供了许多方法来表达--用所有的大写 EMAIL 的强度--做某事是一个非常，非常糟糕的主意。但是，如果你决心滥用代码，并且有足够的知识，几乎没有人可以阻止你。

从 Rust 来，我花了一些时间才注意到这一点，因为（至少在介绍材料中）Raku 把某些东西作为绝对的规则（"私有属性不能在类外访问！"），而实际上，它们变成了措辞强烈的建议（"......除非你以你真正不应该的方式来破坏 Meta 对象协议"）。从 Rust 的角度来看，这是不可能的--私有的实现应该是私有的，而不是在"危险"的标志后面。但它完全符合 Raku 的整体设计理念。

通过图示进行交流

将这一设计理念应用于符号，我开始相信，制作 Possitional、Associative 和 Callable 标记角色是完全正确的选择。毕竟，标记角色完全是通过代码来交流的--即使在 Rust 中，标记特征的整个目的也是为了交流一些 Rust 编译器无法验证的属性。

这对于标记符来说是非常合适的。`@` 是什么意思？它意味着这个变量是有位置的。好吧，Positional 是什么意思？它的意思是 "类似于数组"。...好的。"类似数组"是什么意思？好吧，这要由你来决定，作为与过去和未来的作者合作对话的一部分（审判对话？

这并不意味着你要靠自己，从虚空中创造意义。 Raku 通过确保每个 Raku 恩人都有丰富的使用 Arrry 的经验，使我们保持在同一个总体页面上，这就为"类似数组"的含义创造了共同理解。而且语言文档提供了清晰的解释，说明如何使你的自定义类型表现得像 Raku 的 Array。但是--正如我现在意识到的--Raku 不会跺着脚说 `@`-sigiled 变量必须以特定的方式表现。如果在你的代码库中，在你的多边对话的背景下，有一个既非有序也非可迭代的 `@`-sigiled 变量是有意义的，那么你可以。

所以，我很失望，当我写上一篇文章时，我对 Raku 的语法有误。如果有人被那篇帖子的未更正版本所迷惑，我特别抱歉。但我真的很高兴意识到 Raku 的实际语义，因为它与 Raku 的整体完全吻合。 此外，这些语义不仅更适合 Raku 的设计，而且使 Raku 的符号更适合它们的主要目的：帮助写代码的人清晰简洁地将他们的意图传达给阅读该代码的人

为了与我之前的文章保持一致，我将把我们讨论过的三个符号的语义放在一个表格里。

| Sigil | Meaning                                                |
|:------|:-------------------------------------------------------|
|  @  	| Someone intentionally marked the variable  Positional  |
|  %  	| Someone intentionally marked the variable  Associative |
|  &  	| Someone intentionally marked the variable  Callable    |

这些语义学是完美的，因为归根结底，这就是 `@`, `%`, `&`, 和 `$` 的真正含义：别人的意图的标志。小小的、语义上密集的、神奇的标志。

关于持久化数据结构的简要更新

以下是我在为 Raku 实现持久化数据结构方面的一个非常简短的更新，该结构基于 Phil Bagwell 在 2001 年的论文《理想哈希树》中描述的哈希阵列映射 Trie，并为 Clojure 的标准库实现。关于这个项目的范围、目标和状态的其他细节，你可以参考最初的提案和之前的两次更新

    这个项目的目标是实现 Raku 的内置集合类型的持久化版本。
    这些类型将是不可变的，并将支持结构性共享，这意味着创建副本或更新只需要复制共享数据的一小部分，大大改善了大型数据结构的速度。
    持久的数据结构旨在支持以更多的函数式风格来编写 Raku，这通常需要使用不可变的变量，并在其他编程范式将更新数据的情况下创建这些变量的更新副本。当所涉及的数据结构较小时，Raku 目前为这种风格的编程提供了极强的支持，但在对大型数据结构进行深度复制时，却难以提供可接受的性能。
    实施的进展比我希望的要慢，部分原因是我没有能够像我希望的那样为这个项目投入那么多时间，部分原因是实施的某些部分比预期的要长。
    尽管如此，我在实施方面已经取得了重大进展。到目前为止，我的大部分工作都集中在开发数据结构的低容量版本上，这应该能让我更快地建立起全尺寸版本。
    编写测试也是早期的一个重点。
    我还没有公开发布任何代码，但我预计在未来几个月可以这样做。

