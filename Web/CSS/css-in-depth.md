# 前言

学会 CSS 的规则并不难, 你只需要写一个选择器尝试匹配元素, 然后写一些键/值对给元素添加样式即可。

本书选取的知识点具备以下三个特点之一:

- 基本特性
- 新特性
- CSS 文化

本书有些话题值得另外写一本书去单独介绍，比如：动画、排版，甚至是Flexbox 和网格布局。

# 层叠、优先级和继承

层叠和继承负责控制哪些样式会作用于哪些网页元素。

本书第一部分首先介绍CSS 最基本的原理：层叠、盒模型、可用的各种单位类型。大多数 Web 开发人员知道层叠和盒模型。他们了解像素单位，可能还听说过“应该改用 em 单位”。然
而这类话题太多了，对此一知半解不能让你走得更远。如果要掌握CSS，你一定要理解基础知识，并且是深入地理解。

本章的话题都是关于将特定样式应用到目标元素。

## 层叠

CSS 本质上就是声明规则, 即在各种条件下, 我们希望产生特定的效果。浏览器会根据这些规则, 判断每个规则应该用在哪里, 并使用它们去渲染页面。

首先我们需要理解浏览器如何解析样式规则。每条规则单独来看很简单，但是当两条规则提供了冲突的样式时会发生什么呢？如果你发现有一条规则没有按照预期生效，可能是因为另一条规则跟它冲突了。要想预测规则最终的效果，就需要理解 CSS 里的层叠。

层叠指的就是这一系列规则。它决定了如何解决冲突，是 CSS 语言的基础。

虽然有经验的开发人员对层叠有大体的了解，但是层叠里有些规则还是容易让人误解。下面来分析层叠的规则。当声明冲突时，层叠会依据三种条件解决冲突。

(1) **样式表的来源**: 样式是从哪里来的, 包括你的样式和浏览器默认样式等。
(2) **选择器的优先级**: 哪些选择器比另一些选择器更重要。
(3) **源码顺序**: 样式在样式表里的声明顺序。

> 术语解释

最简单的 CSS:

```css
color: black;
```

这个单行 CSS 被称作一个声明。该声明由一个属性(color)和一个值(black)组成。

不要将 CSS 属性(property)跟 HTML 属性(attribute)混淆。比如在 `<a herf="/">` 元素里, `herf` 就是 **a** 标签的一个 HTML 属性。

包含在花括号内的一组声明被称作一个声明块。声明块前面有一个选择器(比如下面的 body):

```css
body {
    color: black;
    font-family: Helvetica;
}
```

选择器和声明块一起组成了规则集(ruleset)。一个规则集也简称一个规则, 不过我发现
很少有人说单数形式的规则（rule），通常会用复数形式（rules），用来指一系列样式的集合。
最后，@规则（at-rules）是指用 “@” 符号开头的语法。比如 @import 规则或者 @media 查询。

### 样式表的来源

你添加到网页里的样式表并不是浏览器唯一使用的样式表, 还有其它类型或来源的样式表。
你的样式表属于作者样式表, 除此之外还有用户代理样式表, 即浏览器默认样式。用户代理样式表优先级低, 你的样式会覆盖它们。

用户代理样式在不同浏览器上稍有差异, 但是大体上是在做相同的事情: 为标题(`<h1>` 到 `<h6>`)和段落(`<p>`)添加上下外边距, 为列表(`<ol>` 和 `<ul>`)添加左侧内边距, 为链接添加颜色, 为元素设置各种默认字号。

1. 用户代理样式

浏览器应用了用户代理样式后才会应用你的样式表, 即作者样式表。你指定的声明会覆盖用户代理样式表里的样式。如果你在 HTML 里面链接了多个样式表, 那么它们的来源都相同, 即作者。

如果长期使用CSS，你大概习惯了覆盖用户代理的样式。这种做法实际上就是利用了层叠的
样式来源规则。你写的样式会覆盖用户代理样式，因为来源不同。

> 你可能注意到我用了ID 选择器，但应该避免使用这种选择器，稍后会做出解释。

2. !important 声明

样式来源规则有一个例外：标记为重要（important）的声明。如下所示，在声明的后面、分号的前面加上!important，该声明就会被标记为重要的声明。

```css
color: red !important;
```

标记了 `!important` 的声明会被当作更高优先级的来源, 因此总体的优先级按照由高到低排列如下所示:

(1) 作者的 `!important`
(2) 作者
(3) 用户代理

层叠独立地解决了网页中每个元素的样式属性的冲突。例如, 如果给段落设置加粗的字体, 用户代理的上下边距样式仍然会生效(除非被明确覆盖)。处理过渡和动画时, 还会再提到样式来源的概念, 因为它们会引入更多的来源。`!important` 注释是 CSS 的一个有趣而怪异的特性。

### 理解优先级

不理解优先级会被坑得很惨。

浏览器将优先级分为两部分: HTML 的行内样式和选择器的样式。

1. 行内样式

如果用 HTML 的 style 属性(attribute)写样式, 这个声明只会作用于当前元素。实际上行内元素属于“带作用域的”声明, 它会覆盖任何来自样式表或者 `<style>` 标签的样式。行内样式没有选择器, 因为它们直接作用于所在的元素。

为了在样式表里覆盖行内声明，需要为声明添加 `!important`，这样能将它提升到一个更高优先级的来源。但如果行内样式也被标记为 `!important`，就无法覆盖它了。最好是只在样式表内用 `!important`。

2. 选择器优先级

优先级的第二部分由选择器决定。比如, 有两个类名的选择器比只有一个类名的选择器优先级更高。

不同类型的选择器有不同的优先级。比如，ID 选择器比类选择器优先级更高。实际上，ID 选择器的优先级比拥有任意多个类的选择器都高。同理，类选择器的优先级比标签选择器（也称
类型选择器）更高。

优先级的准确规则如下。

- 如果选择器的 ID 数量更多, 则它会胜出(即它更明确)。
- 如果 ID 数量一致, 那么拥有最多类的选择器胜出。
- 如果以上两次比较都一致, 那么拥有最多标签名的选择器胜出。

> 伪类选择器（如 `:hover`）和属性选择器（如 `[type="input"]`）与一个类选择器的优先级相同。通用选择器（`*`）和组合器（`>`、`+`、`~`）对优先级没有影响。

如果你在 CSS 里写了一个声明，但是没有生效，一般是因为被更高优先级的规则覆盖了。
很多时候开发人员使用 ID 选择器，却不知道它会创建更高的优先级，之后就很难覆盖它。如果
要覆盖一个 ID 选择器的样式，就必须要用另一个 ID 选择器。

3. 优先级标记

一个常用的表示优先级的方式是用数值形式来标记, 通常用逗号隔开每个数。比如, “1,2,2” 表示选择器由 1 个 ID、2个类、2个标签组成。优先级最高的 ID 列为第一位, 紧接着是类, 最后是标签。

一旦引入一个 `!important`，就会带来更多的 `!important`。通常最好让优先级尽可能低，这样当需要覆盖一些样式时，才能有选择空间。

### 源码顺序

层叠的第三步，也是最后一步，是源码顺序。如果两个声明的来源和优先级相同，其中一个声明在样式表中出现较晚，或者位于页面较晚引入的样式表中，则该声明胜出。
也就是说，可以通过控制源码顺序，来给特殊链接添加样式。如果两个冲突选择器的优先级相同，则出现得较晚的那个胜出。

正如之前所说，在 CSS 中最好的答案通常是“这得看情况”。实现相同的效果有很多途径。
多想些实现方法，并思考每一种方法的利弊，这是很有价值的。面对一个样式问题时，我经常分两个步骤来解决它。首先确定哪些声明可以实现效果。其次，思考可以用哪些选择器结构，然后选择最符合需求的那个。

1. 链接样式和源码顺序

你刚开始学习 CSS 时，或许就知道给链接加样式要按照一定的顺序书写选择器。这是因为源码顺序影响了层叠。

书写顺序之所以很重要，是因为层叠。优先级相同时，后出现的样式会覆盖先出现的样式。
如果一个元素同时处于两个或者更多状态，最后一个状态就能覆盖其他状态。如果用户将鼠标悬
停在一个访问过的链接上，悬停效果会生效。如果用户在鼠标悬停时激活了链接（即点击了它），激活的样式会生效。
这个顺序的记忆口诀是 “LoVe/HAte”（“爱/恨”），即 link（链接）、visited（访问）、hover（悬停）、active（激活）。注意，如果将一个选择器的优先级改得跟其他的选择器不一样，这个规则就会遭到破坏，可能会带来意想不到的结果。

2. 层叠值

浏览器遵循三个步骤，即来源、优先级、源码顺序，来解析网页上每个元素的每个属性。如果一个声明在层叠中“胜出”，它就被称作一个层叠值。元素的每个属性最多只有一个层叠值。
网页上一个特定的段落（`<p>`）可以有一个上外边距和一个下外边距，但是不能有两个不同的上外边距或两个不同的下外边距。

如果 CSS 为同一个属性指定了不同的值，层叠最终会选择一个值来渲染元素，这就是层叠值。

> 层叠值: 作为层叠结果, 应用到一个元素上的特定属性的值。

### 两条经验法则

(1) 在选择器中不要使用 ID。

就算只用一个 ID，也会大幅提升优先级。当需要覆盖这个选择器时，
通常找不到另一个有意义的 ID，于是就会复制原来的选择器，然后加上另一个类，让它区别于想要覆盖的选择器。

(2) 不要使用 `!important`。

它比 ID 更难覆盖，一旦用了它，想要覆盖原先的声明，就需要再加上一个 `!important`，而且依然要处理优先级的问题。

## 继承

如果一个元素的某个属性没有层叠值, 则可能会继承某个祖先元素的值。比如通常会给 `<body>` 元素加上 `font-famly`, 里面的所有后代元素都会继承这个字体, 就不必给页面的每个元素明确指定字体了。

但不是所有的属性都能被继承。默认情况下, 只有特定的一些属性能被继承, 通常是我们希望被继承的那些。它们主要是跟文本相关的属性: color、font、font-family、font-size、font-weight、font-variant、font-style、line-height、letter-spacing、text-align、text-indent、text-transform、white-space 以及 word-spacing。

还有一些其它的属性也可以被继承, 比如列表属性: list-style、list-style-type、list-style-position 以及 list-style-image。表格的边框属性 border-collapse 和 boder-spacing 也能被继承。注意, 这些属性控制的是表格的边框行为, 而不是常用于指定非表格元素边框的属性。

```css
body {
    font-family: sans-serif; /*继承属性也会作用于后代元素*/
}
```

## 特殊值

有两个特殊值可以赋给任意属性, 用于控制层叠: inherit 和 initial。

- 使用 inherit 关键字

有时, 我们想用继承代替一个层叠值。这时候可以用 inherit 关键字。可以用它来覆盖另一个值, 这样该元素就会继承其父元素的值。

```css
a:link {
    color: blue; /*全局的网页链接颜色*/
}

.footer {
    color: #666; /*页脚的文本设置为灰色*/
    background-color: #ccc;
    padding: 15px 0;
    text-align: center;
    font-size: 14px;
}

.footer a {
    color: inherit; /*从页脚继承文本颜色*/
    text-decoration: underline;
}
```

第三个规则集覆盖了蓝色的链接色, 让页脚链接的层叠值为 inherit。因此, 它继承了父元素 `<footer>` 的颜色。

这么做的好处是, 如果页脚发生任何样式改变的话（比如修改第二个规则集, 或者被别的样式覆盖）, 页脚链接的颜色就会跟着其它内容一起改变。比如, 当页脚文本变为更深的灰色时, 其中的链接也会跟着改变。

- 使用 initial 关键字

有时, 你需要撤销作用于某个元素的样式。这可以使用 initial 关键字来实现。每一个 CSS 属性都有初始（默认）值。如果将 initial 值赋给某个属性, 那么就会有效地将其重置为默认值, 这种操作相当于硬复位了该值。

```css
.footer a {
    color: initial;
    text-decoration: underline;
}
```

这么做的好处是不需要思考太多。如果想删除一个元素的边框，设置 border: initial 即可。
如果想让一个元素恢复到默认宽度，设置 width: initial 即可。你可能已经习惯了使用 auto 来实现这种重置效果。
实际上，用 width: auto 是一样的，因为 width 的默认值就是 auto。

## 简写属性

简写属性是用于同时给多个属性赋值的属性。比如 font 是一个简写属性, 可以用于设置多种字体属性。它指定了 font-style、font-weight、font-size、font-height 以及 font-family。

```css
font: italic bold 18px/1.2 "helvetica", "Arial", sans-serif;
```

还有如下属性。

- background 是多个背景属性的简写属性: background-color、background-image、background-size、background-repeat、background-position、background-origin、background-chip 以及 background-attachment。

- border 是 border-width、border-style 以及 border-color 的简写属性, 而这几个属性也都是简写属性。

- border-width 是上、右、下、左四个边框宽度的简写属性。

简写属性会设置省略值为其初始值。

# 相对单位

像素单位(px)是绝对单位, 即 5px 放在哪里都一样大。而其它单位, 如 em 和 rem, 就不是绝对单位, 而是相对单位。相对单位的值会根据外部因素发生变化。比如, 2em 的具体值会根据它作用到的元素（有时甚至是根据属性）而变化。因此相对单位的用法更难掌握。

## 相对值的好处

CSS 为网页带来了后期绑定(late-binding)的样式: 直到内容和样式都完成了, 二者才会结合起来。

响应式: 在 CSS 中指的是样式能够根据浏览器窗口的大小有不同的“响应”。这要求有意地考虑任何尺寸的手机、平板设备，或者桌面屏幕。

## em 和 rem

em 是最常见的相对长度单位, 适合基于特定的字号进行排版。在 CSS 中, 1em 等于当前元素的字号, 其准确值取决于作用的元素。