原文链接: https://raku-advent.blog/2022/12/20/sigils/

![img](https://rakuadventcalendar.files.wordpress.com/2021/12/grawlix-1.jpg)

符号--那些奇怪的、非字母的前缀字符，许多程序员将其与 Bash 脚本联系起来；`echo $USER` 中的 `$`--名声有点坏。一些程序员似乎认为符号是"老式的"，也许是因为在上个千年首次流行的几种语言（如 [BASIC](https://en.wikipedia.org/wiki/BASIC)、[Bash](https://en.wikipedia.org/wiki/Bash_(Unix_shell))、[Perl](https://en.wikipedia.org/wiki/Perl) 和 [PHP](https://en.wikipedia.org/wiki/PHP)）都使用符号。其他程序员只是认为符号没什么意义。[根据这种观点](https://wiki.c2.com/?TheProblemWithSigils)，符号是变量名称中"编码类型信息的一种方式"--基本上是[应用匈牙利语符号](https://en.wikipedia.org/wiki/Hungarian_notation#Systems_Hungarian_vs._Apps_Hungarian)的美化版本（甚至不是[好的那种匈牙利语符号](https://www.joelonsoftware.com/2005/05/11/making-wrong-code-look-wrong/)）。也许在过去的坏日子里，符号是有作用的，但现在我们有了漂亮的 IDE 和编辑器，可以给我们提供我们可能想要的[所有类型信息](https://code.visualstudio.com/docs/languages/typescript#_hover-information)，这些现代工具已经使符号过时了。现在我们有了 VS Code，再也没有理由冒着有人用符号写出的代码看起来有点太像它的[行噪声](https://rachelbythebay.com/w/2011/10/02/linenoise/)或[极其愤怒的漫画人物](https://en.wikipedia.org/wiki/Grawlix)的风险了。

![img](https://rakuadventcalendar.files.wordpress.com/2021/12/grawlix-1812061347-e1671333426773.png?w=433&h=246)

他们也是这么说的。但我不同意--正如[许多](https://hillelwayne.com/)我最看重的[黑客](https://perl6advent.wordpress.com/2017/12/02/perl-6-sigils-variables-and-containers/)的[观点](https://stackoverflow.com/a/62142436/)和[见解](https://www.youtube.com/watch?v=pvDZUlNHGCw)一样。

因此，我在这篇文章中的目标是要说服你，符号是编写清晰、有表现力的代码的有力工具。事实上，我还会更进一步。符号通常是清晰交流的有力工具--它们对编程的作用只是更普遍规则的应用。

为了支持这一说法，我们将首先看一下三种非编程情况，在这些情况下，符号有助于清晰、有表现力的交流。其次，我们将利用这些例子来理解符号是如何工作的--是什么让它们具有表现能力？是什么让某个特定的符号在其工作中表现得好或坏？

一旦我们大致掌握了符号，我们将回到编程语言中的符号这一具体案例。我们将看到，编程语言中的符号有助于编写清晰的代码，就像其他符号有助于清晰的交流一样--但编程语言的符号也面临一些独特的挑战，并获得一些额外的力量。

我的目标是，在这篇文章结束时，你会对符号的工作原理有更好的理解，还有一个新的心智工具应用于你的（编程和非编程）交流，以及--只是可能--对[那些看起来像在对你发誓的语言](https://developers.slashdot.org/story/16/07/14/1349207/the-slashdot-interview-with-larry-wall#:~:text=A%20common,swearing)有更多的感激。

## 三种有助于提高清晰度的非编程符号

> 符号定义
> 
> 既然这篇文章是关于符号的，让我们确保我们对"符号"的含义达成一致。按照我对这个词的用法，符号就是:
> 
>     1. 一个非字母字符
>     2. 位于单词的开头
>     3. 它传达了关于这个单词的元信息。
> 
> 因此，在 `echo $USER` 中，`$` 是一个符号，表示 `USER` 是一个变量。

1. 谈论符号

如果你曾经在网上与程序员交谈过，你可能会看到有人这样说话:

    我们在 `$day_job` 遇到了这个问题：我们的代码一团糟，但每个人都认为 `$framework` 会神奇地解决问题。

我的意思不是说你已经看到有人表达了这种情绪（虽然你可能有情绪, 但让我们面对它）。相反，我的意思是，你可能已经看到有人使用 `$day_job` 或 `$framework` 这样的术语。而且，即使你没有见过，你也可能知道他们的意思。

在这两种情况下，`$` 符号标志着一个占位词--在 `$day_job` 中，可能是因为说话者不想透露他们的工作地点；在 `$framework` 中，是为了避免将对话变成关于某个特定框架的优点的辩论。当然，这两个符号都不是必需的；你可以重写这个句子，使用 “at my day job” 或 “a new framework” 这样的短语。

因此，使用符号可以为我们节省几个字，你可能认为这个好处微不足道。但是，在同步通信的背景下，这真的不是小事--任何能减少整个团队花在看 `$boss is typing...` 消息的时间(看到我做了什么了吗)都是明显的胜利。

符号的更重要的好处是提高了清晰度。“a new framework” 传达了说话者正在谈论某个不确定的框架，没了。如果你想知道哪个框架，自然要问。相反，`$framework` 表示说话者有意识地决定省略框架的名称。有人可能还是会问，但他们会意识到他们在问一个被故意隐瞒的细节。

2. 既然你提到了这一点...

当然，如果符号可以向人类传达一些信息，它们也可以向计算机传达一些信息。这给我们带来了如今每个人使用符号的方式(即使他们不知道这个词): 提及(mentions)和/或标签(hashtag)。

![img](https://rakuadventcalendar.files.wordpress.com/2021/12/xkcd_sigil-cycle.png?w=507&h=310)

每次程序员在 GitHub 上 `@` 某人--就这一点而言，每次有人将自己描述为 `#blessed` 或将帖子标记为 `#nofilter` -- 他们都在使用符号。

> 这似乎有点违反直觉，所以让我们对照我们的定义仔细检查 "#nofilter"。
>     `#` 是单个非字母符号吗? ✔
>     `#` 是用在单词的开头吗? ✔
>     `#` 交流了元信息吗? ✔
> 
> 事实上，`#` 不仅向读者传达了一些信息(`#nofilter` 是文章的一个标签，而不是文本)，也向计算机传达了一些信息(相关的文章应该可以在 `www.distopic-social-media.io/tags/nofilter` 看到)。

## 也许你对此有什么反应？

当我们在讨论标签和 `@mentions` 的时候，让我们简单地岔开话题，谈谈虽然在技术上不是符号，但却密切相关的东西：[表情符号](https://www.makeuseof.com/how-to-react-to-messages-in-iphone/)--那些对[短信](https://9to5google.com/2022/09/28/apple-imessage-reactions-android/)、[GitHub issues](https://github.blog/2016-03-10-add-reactions-to-pull-requests-issues-and-comments/) 和 [Slack 聊天](https://slack.com/help/articles/202931348-Use-emoji-and-reactions)的表情符号式反应。不管你喜欢还是[讨厌](https://slate.com/human-interest/2019/05/iphone-reactions-group-texts-chats-bad.html)，我相信你已经见过它们。

它们不是符号(它们是单独使用的，不是作为单词的前缀)。但它们值得在此讨论，因为--像符号一样--它们利用了人类本性中的一个内在元素：我们是视觉的，并且用符号思考。GitHub 完全可以用文字来取代他们所有的表情符号。事实上，他们列出了每个符号的文字对应关系。👍 ⇒ +1；👎⇒ -1；😀 ⇒ 微笑；😕 ⇒ 困惑；♥ ⇒ 心；以及 🎉 ⇒ tada。那么，为什么 GitHub 使用符号而不是相应的文字？

因为当你对项目里程碑做出反应时，用 🎉 来表达兴奋/祝贺的方式比用语言来表达要好得多--比说 "tada" 要好得多。同样，像 👍 和 👎 这样的符号也是向理解该符号的人传达赞同或不赞同的直接方式。当然，有些文化对竖起大拇指的手势赋予了非常不同的含义；我完全不是在说 👍 神奇地避免了歧义。

但是，如果有人确实理解 👍，那么他们就直接把它理解为单个符号。他们不是把 👍 翻译成 "我赞成和/或同意"，就像一个懂数学的人把 "a÷(b×c)" 翻译成"'a'的商除以'b'和'c'的积"一样。在这两种情况下，他们都是直接用符号进行推理；不需要翻译。(也可参见 APL-家族编程语言，它将符号推理的力量的洞察力发挥到了（非）逻辑的极限）。

3. 在电子邮件中，标签>文件夹--但符号是我的秘密武器

到目前为止，我们已经讨论了两个非编程的例子，在那里你可能已经遇到了符号和符号交流的力量。对于我们的第三个例子，让我们看看一个你不那么熟悉的环境：我用来管理我的电子邮件收件箱的系统。

在过去的十年里，我基本上没有整理过我的电子邮件。相反，我遵循了[2011年一项关于电子邮件重新查找的研究](https://people.ucsc.edu/~swhittak/papers/chi2011_refinding_email_camera_ready.pdf)的建议：把所有的东西都扔到一个单一的档案库中，然后更好地进行搜索。也许这在当时是正确的，或者我只是想找一个借口来点击 `Archive All` 按钮。但是到了去年，这个系统显然已经停止工作了--在我不同的项目、委员会、邮件列表和补丁列表之间，我得到了太多的相关邮件，无法有效地搜索单个档案。

所以我转而使用 [Thunderbird](https://www.thunderbird.net/en-US/) 过滤器。但与许多人不同的是，我不是用过滤器来使邮件跳过我的收件箱；我喜欢看传入的邮件流。相反，我使用过滤器以程序化的方式给收到的邮件贴上标签（例如，来自/发往 Raku 指导委员会的邮件被贴上 "RSC" 标签）。而当我归档邮件时，其他过滤器会根据标签将邮件移到正确的文件夹中。

但这让我做了一个决定：我的标签应该具有文件夹语义（每封邮件正好在一个文件夹中）还是标签语义（邮件可以有任何数量的标签，包括零）？这个相当有[争议](https://www.obsidianroundup.org/yet-another-hot-take-on-folders-versus-tags/)--它已经被争论了多年，但那篇文章仍然产生了[140多条辩论的评论](https://news.ycombinator.com/item?id=30063301)。这两种方法的优点在这里并不重要；我只想说，我最终决定使用这两种方法的一部分。

具体来说，我决定给四个标签文件夹语义。`Word`、`Life`、`List` 和 `Bulk`。我收件箱中的每封邮件都应该被自动分配到这些标签中的准确一个--如果它的标签多于或少于一个，就说明出了问题，我需要修正我的过滤规则。而当一封邮件被归档时，它应该被移到与这些文件夹标签之一相对应的文件夹中。

但是，除了这四个标签之外的每一个标签都有标签语义：它们是可选的，电子邮件可以有任何数量的这些 tag-labels。例子包括 `Raku`, `RSC`, `TPRC`, `Family`, `Rust`, `conference`, `guix` 和 `blogs`。

到目前为止，很好--但也与符号无关。符号是如何进入这个画面的呢？

嗯，我最终有两种不同类型的标签（文件夹标签和 tag 标签），每一种都有不同的语义。此外，我需要能够快速区分这两种类型的标签，以便我能够注意到那些没有确切的文件夹标签的邮件。

这是个需要符号的工作。我在我的文件夹语义标签（⋄Work , ⋄Life , ⋄List , 和 ⋄Bulk）上添加了⋄符号，并在我的标签语义标签（例如，•Raku 或 •Family）上添加了 • 符号。现在，如果我看到一封标记为 ⋄Work、•Raku、•rainbow-butterfly、•RSC 的电子邮件，我就可以立即看到它只有一个文件夹语义标签。但是，如果我看到一个带有 •Family（家庭）、•Parents（父母）、•conference（会议）的，我就会知道它缺少文件夹语义标签。

## 为什么 ⋄Work 和 •Raku 中的符号很重要？

使用 ⋄Work 和 •Raku 解决了一个问题--一个没有类似的好的、非符码的解决方案的问题。当我们讨论 `$day_job` 时，标志是有帮助的，但不是必须的：说"我的日常工作"可能90%的效果都是如此。

但在这里，并没有类似的 90% 的解决方案。我们不能让文件夹标签和标签不加区分；那会造成混乱。那么，我们对 `$day_job` 采用的"用你的话"的方法呢？这里的等效替换是用 primary_Work 这样的标签来代替 ⋄Work。但是，尽管 primary_Work 确实传达了标签有文件夹的语义，这种替换的代价远远超过我们对 `$day_job` 所估计的 10%。

事实上，primary_Work 是 ⋄Work 的一个糟糕的替代品，原因与"困惑"是😕的一个糟糕的替代品一样：在这两种情况下，从符号到文本的转换都大大增加了认知负荷，相应地减缓了阅读速度。换句话说，⋄Work（心理上）读作 "工作"，而不是 "主要工作"。

事实上，⋄Work , Work , 和 work 的 "发音 "都是一样的（除非你是 Terry Pratchett 的角色，我想）。这种相同的发音突出了符号是如何像大写字母一样的：符号和大写字母都是在不改变该词现有意义或使该词不容易阅读的情况下为现有的词添加信息。

大多数编程语言至少在某些时候使用大写字母，经常用于类名。如果我们认为使用大写字母来表达意图是有意义的，那么，符号只是同一想法的一个轻微延伸。除了符号也是一种改进，因为书面英语的正常规则已经赋予大写字母以意义。任何编程语言在此基础上的额外含义都可能发生冲突--这常常出现在首字母缩写中。这就是为什么大写字母不能区分我的电子邮件标签：如果 Work 中的大写字母 "W" 表示文件夹标签，那么它就会与 RSC 首字母的大写字母冲突。

⋄Work 以符号方式传达信息，这使得理解这些信息更加容易和快速。反过来，更快的理解意味着一目了然地阅读 ⋄Work, -Raku, -rainbow-butterfly, -RSC 是实用的，但阅读 primary_Work, secondary_Raku, secondary_rainbow-butterfly, secondary_RSC 则不是。⋄Work 的可读性有远远超过 10% 的提高，而这种差别是 100% 的符号。

从非编程的符号图中学习

我们看了三个半的例子，在这些例子中，符号在非编程环境中起到了帮助作用：聊天信息、标签和电子邮件标签（加上表情符号反应的一半功劳）。在每一种情况下，使用符号都能让我们更清楚地交流。但我们能从这些例子中归纳出对符号力量的解释吗？

我认为可以。符号是强大的，因为它们使用语义密集的符号，快速而容易地向读者传达有意义的、低背景的信息。这句话很拗口，所以让我们把它拆开来，一次一个术语。

2. 符号使用语义密集的符号

符号的决定性特征是它们是象征性的：⋄Work 使用符号；primary_Work 不使用符号。符号的象征性是其力量的关键：因为它们将整个短语的价值编码到一个字形中，所以它们的语义密度高得多。换句话说，它们可以让你用更少的钱说更多的话。

当然，认识到代码的价值，将大量的意义装入一个小包装中，并不是一个新的见解。观察到符号在简洁的交流方面是特别好的，这也不是什么新见解。几年前，Hillel Wayne 提出了类似的观点。
![img](https://rakuadventcalendar.files.wordpress.com/2021/12/hillel-wayne_tweet.png?w=504&h=353)

事实上，30 多年来，APL 程序员们实际上一直在屋顶上喊着这个观点。APL 的设计者 [Ken Iverson](https://en.wikipedia.org/wiki/Kenneth_E._Iverson) 在其 1979 年著名的图灵奖演讲[《作为思维工具的记号》](https://www.jsoftware.com/papers/tot.htm)中，一开始就提出了这个观点。

    代数符号将意义的数量压缩到很小的空间里，这是另一种情况，有利于我们习惯于在其帮助下进行推理。

但这不是艾弗森的话：他引用的是[查尔斯-巴贝奇](https://en.wikipedia.org/wiki/Charles_Babbage)（"计算机之父"，如果这甚至是一个有意义的标题的话）[在 1826 年出版的一本书](https://books.google.com/books?id=b4Y_AAAAcAAJ&vq=compressed&pg=PA6#v=snippet&q=compressed&f=false)。然后，为了完成引用的循环--并将关注语义密度是普遍的这一观点带回家--[保罗-格雷厄姆](https://en.wikipedia.org/wiki/Paul_Graham_(programmer)在他 2002 年的文章[《简洁就是力量》](http://www.paulgraham.com/power.html)中引用了艾弗森（引用了巴贝奇）。

我可能不像格雷厄姆的文章那样高度重视简洁性，但很难否认符号的表达简洁性提供了相当多的力量。事实上，我们可以从我们讨论过的一个非程序化的符号中看到这种表达能力的证据。标签的表现力很强，甚至开始[进入口语](https://www.tintup.com/blog/how-hashtags-changed-the-way-we-talk/)。

2. 符号可以被快速和容易地使用

鉴于符号在创造富有表现力、语义密集的代码方面的巨大力量，为什么我们不应该把它们用于所有的事情？每个人都应该用 APL 编程吗？有没有一种代码是语义过于密集的？

![img](https://rakuadventcalendar.files.wordpress.com/2021/12/apl-code.jpg?w=750)

尽管我很欣赏 APL，但我认为它搞错了平衡。我欣赏符号，但我也喜欢文字（我知道，你很震惊，很震惊地了解到你刚刚阅读的~2.5千字的负责人）。因此，有几句话要为文字辩护：尽管符号提供了巨大的语义密度，但它们牺牲了灵活性；当符号对文字起辅助作用时，它们是最好的。它们是标点符号，而文字是，嗯，文字。

完全拥抱符号的另一个弊端可以从 APL 压倒性的符号数量中看出。APL 的大量符号的问题不在于学习曲线--这需要时间，但资深的 APL 使用者早已掌握了这些词汇。相反，APL 极其庞大的符号词汇的问题在于，它挤占了用户创造的词汇。

这给用户留下了很少的空间来发展他们的语言，或者用特定的语言来解决特定的问题；也就是说，它不鼓励 DSLs。而且，事实上，一些最好的 APL 程序员并不喜欢 DSLs。我尊重这种观点，但尊重地不同意。
当然，这是一种平衡的行为：一种语言有可能鼓励 DSL 广泛扩散，以至于用户最终用不兼容的方言编写，无法有效地合作。但这并不是完全抛弃 DSL 的理由--尤其是考虑到像 [Racket][w:racket] 中的 #lang s 或 Raku 中的 slangs（正在进行中）这样的语言特性的存在，它们支持以一种结构化的方式使用 DSL，以使方言之间更好地协作。

那么，如果我们不想完全接受符号，APL 式的，我们应该在哪里与 sigils 划清界限？

好吧，我们希望我们的符号既能让人记住，又能让人快速识别。这既能帮助新用户更快地学习它们，又能让有经验的用户在不花费任何认知努力的情况下阅读符号。

或者，换一种说法，好的符号图应该是容易使用的--但在 Rich Hickey 的 Simple Made Easy 谈话中，是非常具体的意义上的容易。Hickey 区分了"简单"（客观上衡量某物是如何相互交织/"融合 "的）和 "容易"（主观上衡量某物是如何熟悉和实践/"近在咫尺 "的）。
这是对一个了不起的演讲的巨大简化，该演讲涉及从古代编织到功能性软件设计的一切。这绝对值得一看。

Hickey 区分了简单和容易，以支持简单性。一般来说，我同意。但在符号（或更广泛的符号）的具体案例中，我认为使它们容易--在 "近在咫尺 "的意义上--是至关重要的。简单很重要，因为符号的力量主要来自于它们几乎免费向有经验的读者传达的能力。

例如，当我看到 `@codesections` 时，我感觉到我被提到了，而没有对 `@` 进行任何有意识的思考。 `@` 向我传达的方式与 "白宫"中的大写字母传达的方式相同，我们正在谈论美国总统，而我从未想过 "哦，大写 W 意味着专有名词"。但是，只有当符号确实非常近在咫尺时，符号才能获得这种无意义的效果。

让符号符号变得简单的一个方法是让它们在视觉上与众不同。我们看到的 `$` , `#`, `@`, `⋄`, 和 `-` 都通过了这个标准。相比之下，使用😀、😃和😄作为符号符号就不容易了。

此外，如果用户经常阅读这些符号，就更容易使用。因此，可能不应该有很多符号，而每一个符号都应该经常使用。关于这一点做得好的例子，请考虑社交媒体对 `#` 和 `@` 的使用--只有两个标志，都是日常使用的。我的 "⋄" 和 "-" 符号也是如此：它们被应用于我所有的电子邮件，所以我每天都在使用这两个符号。

最后，如果用户练习使用签名，那么签名会更容易使用，所以签名应该方便输入。当然，由于"容易"是一个主观的问题，"方便输入"取决于符号的使用者。因此，`⋄` 和 `-` 对于他们的目标用户--我--来说是很好的符号，因为合成键可以让我毫无痛苦地输入它们。但是，对于那些认为输入非 ASCII 字符很困难的用户群体来说，他们就不应该选择这些符号。这种描述可能适用于足够多的程序员，至少在现在，编程符号可能最好坚持使用 ASCII......尽管这有点 ☹。

当符号遵循这些规则时--它们在视觉上是独特的，数量少，并且经常被阅读和使用--它们实际上能够免费沟通。这是很强大的。

3. 符号必须传达有意义的、低背景的信息

早些时候，我们说过，符号具有高语义密度，因为它们很短。但是，当然，这隐含着一个假设，即它们传达了一些有用的意义。如果它们没有任何意义，那么它们就真的是低语义密度的字符，只是碍手碍脚而已--也就是说，是行噪音（line noise）。

回到我们开始的例子，如果有人说

    我们在 `$day_job` 遇到了这个问题：我们的 `$code` 是个 `$mess`，但是大家都认为 `$framework` 会 `$magically` fix it。

......那么这就不是在使用符号，这只是在混淆视听。

此外，符号应该不仅仅是传达一些有用的信息；它们应该以一种低语境的方式传达这些信息。所谓低语境，我的意思是，读者应该能够通过纯粹的局部推理来掌握该词的全部含义。当一个词有一个好的符号--比如 ⋄Work --你可以孤立地看这个有标志的词，并完全掌握其含义。

相比之下，考虑一下 GitHub 的 `#` 标记的问题和拉取请求（例如，`#1066`）。我认为这些是悲惨的符号。但问题不在于 `#1066` 没有传达有用的信息：它传达的是 1066 指的是当前版本中的一个问题或 PR（而不是，例如，一年）。而且，通过将这个数字与问题和 PR 的列表对照，你可以知道它是关于什么的。但这一信息需要与当前环境之外的数据进行交叉参考--也就是说，这些数据在本地是不存在的。

依靠外部环境会降低符号的效用，因为人类真的很难一次记住超过几件事情--每当我们试图超过这个门槛时，程序员就会经常被强行提醒这个事实。因此，我们真的不想要那些需要读者在他们的短期记忆中保持额外的、非本地的背景的符号。

一个好的符号应该避免这种情况；它的含义应该是立即和局部的清晰。

编程语言的符号

编程语言的符号与其他情况下的符号很相似。他们用一个符号来表达很多东西，而且很简洁；要做到这一点，他们必须传达易于理解的低语境信息。但是，编程在一个基本方面与其他交流环境不同，这种不同意味着编程符号面临独特的挑战和机会。

编程和其他交流形式的关键区别在于，代码总是有两个受众：人类读者和计算机。有些程序员的目标是为人而写，只是顺便为计算机而写；另一些程序员可能更乐意用不加修饰的十六进制数字来编写，根本没有人类读者。然而，正如唐纳德-克努斯（Donald Knuth）所观察到的，程序必须总是既为计算机执行又为人类理解而编写。

这种双重性同样适用于符号：当作者在他们的代码中加入一个符号时，他们同时在向编译器和该代码的读者传达信息。由于人类读者依赖于他们对计算机进行准确建模的能力，所以赋予符号的语义必须不惜一切代价避免向这两个受众提供不一致的信息。

但有一个微妙但关键的细微差别：通常，一个符号向读者传达的信息是关于它传达给计算机的信息。作为一个类比，请回想一下哈希特标签和 `@` 提及的标志。使用 `#` 告诉读者，下面的词是一个标签--但下面的词只是一个标签，因为 `#` 告诉计算机要这样对待它。`#` 并不是不一致的沟通；它向计算机传达了一些东西，引起了变化，并同时向读者传达了这种变化。这种模式在许多编程符号中也有体现，是其表现能力的关键来源。

作者、计算机和读者之间的三方对话在另一个方向也起作用：正如代码作者与读者和计算机都在交流一样，计算机也可以与作者和读者交流。(遗憾的是，这种对称性并没有延伸到读者与作者进行时间上的交流，尽管这将大大简化软件维护。）

计算机→作者通信的一个结果是，如果作者试图使用一个无效的符号，计算机会进行干预。因此，即使是最弱的符号版本也不会还原成匈牙利语符号--最坏的情况是，它将是编译器验证的匈牙利语符号。

但是，无论如何，由于计算机→读者的交流，对变量的类型进行编码并不是一个好的用途。具体来说，计算机可以将类型信息传达给读者，而那些怀疑类型的人是对的，IDEs/编辑人员已经很擅长这样做了。但是，这些怀疑论者似乎忽略了一点，那就是无论如何，符号可以传达更有意义的各种信息。使用一个符号来表示类型是对一个完美的标志的浪费，所以 IDE 提供的类型信息是完全不真实的。

如果一个符号不应该传达类型信息，那么一个符号应该传达什么？嗯，这个问题在抽象上是无法回答的--它取决于提供符号的特定编程语言的需要。我将讨论我最熟悉的语言--Raku--你一定预料到它最终会出现在这个 Raku Advent Calendar 帖子上。

Raku 如何使用符号

现在不是向你介绍 Raku 的时候，但为了防止你不熟悉 Raku ，我只想说，你应该能够在没有任何 Raku 特定知识的情况下了解下面的一切。嗯，到目前为止，Raku 是我最喜欢的编程语言；我相信它几乎是编写自由软件的理想语言--在很大程度上是因为 Raku 提供了一个小团队所需的表达能力，可以跟上一个大的技术团队。而其中的一些力量来自于 Raku 的符号。

1. 没有符号的 Raku

在我们看 Raku 的符号之前，我想说的是，你可以在没有任何符号的情况下编写 Raku；它们是一个特性，而不是一个要求。例如，JavaScript 代码 `const foo = 42` 可以用 Raku 写成 `my \foo = 42`。 Raku 人选择使用这些符号是因为他们--我们--相信它们能使代码更清晰。让我们来看看为什么。

2. 使用符号符号的 Raku 

Raku 提供了一些符号，让你（向计算机和读者）传达一个变量支持什么接口--也就是说，你可以如何使用这个变量。Raku 有四种符号；下面是每种符号所传达的信息。

     @ 说 "用类似数组的接口来使用我"
     % 说："用类似哈希的接口来使用我"
     & 说 "用类似函数的接口来使用我"
     $ 说："我不会告诉你可以使用什么接口，但要把我当作一个单独的项"

而且，就像标签和 `@mentions` 一样，sigil 并不是在那里记录一些已经是真的东西：它使一些东西成为真的，并告诉读者。就像你不会先在 Mastodon/Twitter 上创建一个标签，然后再添加一个 `#` 一样，在 Raku 中，你不需要创建一些具有类似数组接口的对象，然后再添加一个 `@`。 相反，使用 `@` 给它提供了这种接口。

你可能已经注意到，我一直在说"有一个类似数组的接口"，而不是"是一个数组"。这是因为--这是一个关键的区别--Raku 的符号并不对类型信息进行编码。它们只告诉你可以使用什么接口。

让我们看一下 Raku 的 Buf 类型作为一个例子。在 Raku 中，我们使用 Buf 来保存二进制数据（而不是像其他语言中的数组）。而 Buf 不是数组，也不是 Array 的任何子类型。但是它们可以使用类似数组的接口，所以它们可以被存储在 @-siglied 变量中。对于你创建的任何自定义类型也是如此：任何实现了类数组接口的类型都可以使用 `@`。

这是用角色来实现的，Raku 相当于 tyneclasses/concepts/traits/protocols--也就是那个编程世界不能决定叫什么的想法。

让我们对我们一直在谈论的这个"类似于数组的接口"有更具体的了解。这个接口更正式的名称是 Positional；它的意思是："我是一个事物的集合，你可以通过把项目的编号放在方括号里来访问一个特定的项"。也就是说，`@foo` 中的 `@` 表示 `@foo[5]` 可以访问索引为5的项目。迭代一个 `@` 符号的变量意味着从0开始对该变量进行索引，一直到你得到最高索引。这种迭代策略的实际效果是，我们每次都能按顺序得到项。

其他三个符号同样简单。`%` 表示一个类似哈希的接口（技术名称为关联）：它存储键值对，`%foo` 可以用 `%foo<key>` 进行索引。迭代一个 `%-sigiled` 变量意味着产生键值对，直到我们用完为止。这些对可以以任何顺序产生--一般来说，`%-sigiled` 变量在迭代过程中不保留顺序。

`&` 意味着一个类似于函数的接口（技术名称：可调用）：它可以像一个函数一样被调用，如 `&foo()`。

最后，`$` 根本不保证任何接口--它只是告诉你（和编译器）把变量看作一个单一的实体（技术名称：Scalar）。

把变量当作单一实体是什么意思？好吧，想象一下，我有一个杂货清单，上面有五种成分。说我有一样东西（清单）是真的，但说我有五样东西（食物）从某种角度来说也是真的。使用 `$` 与 `@` 或 `%` 来表达 Raku 的这种差异。因此，如果我在 for 循环中使用 @grocery-list，循环的主体将被执行五次。但是如果我使用 $grocery-list，循环就会被执行一次（以列表为参数）。

这不仅仅适用于 for 循环；Raku 有很多地方可以对整个集合或集合中的每个项进行操作（这经常出现在 variadic 函数中）。这个符号告诉 Raku 在这些情况下的行为：它把 `$grocery-list` 当作一项，但对 `@grocery-list` 中的每种食物进行操作。如果需要的话，我们可以暂时选择其他的行为，但这个符号提供了一个提醒，使我们和 Raku 保持一致。

奖励权力和默认值

Raku 的符号有一些额外的权力，这些权力并不是他们接口的直接组成部分--它们只是额外的好处。

这些好处中的第一个是插值。在 Raku 中，每一个有符号的变量都有资格在正确的字符串中进行插值。确切的细节取决于符号，不值得在这里讨论（主要是基于字符在字符串中的典型使用方式--"daniel@codesections.com" 默认不插值，这很好）。你可以有选择地启用/禁用特定符号的插值，或者在通常不允许插值的字符串中用 `qq[ ]` 暂时启用插值（比如 JavaScript 的 `${ }`）。在这之间，它对 Unicode 的支持，以及合理化的 regex DSL 系统，我准备自信地宣称 Raku 的文本操作设施大大超过了我尝试过的任何语言。

第二个好处是一些语法糖，只适用于 &-sigiled 变量，但这也是 Raku 独特外观的一个原因。我们已经说过，你可以用 `&foo()` 这样的语法来调用 &-sigiled 变量。但是由于与 `&` 相关的语法糖，你也可以通过省略 `&` 和小括号来调用它们。因此，在 Raku 代码中，你通常只在有人对一个函数进行调用以外的操作（比如将其传递给高阶函数）时看到 `&`。我以前写过一篇博客，讲到你可以用额外的小括号来编写 Raku，使它的语法和语义惊人地接近 lisp 的语法和语义，所以只有公平地指出，由于这个 `&` 的好处，编写 Raku 有可能基本上没有小括号。

最后，`@` 和 `%` 符号提供了一个默认类型。我已经提到过几次，`@` 并不意味着变量是一个数组，只是它提供了一个类似数组的接口。新的 Rakoons 有时会对此感到困惑，也许是因为你看到的许多 `@` 符号的变量（尤其是刚开始的时候）恰好是数组，而许多 `%` 符号的变量恰好是哈希。这并不太令人惊讶；有序-可变-列表和键值-hashmap 都是有用的、通用的抽象--JavaScript 能够在只有哈希和对象的情况下生存这么多年，是有原因的。

为了支持 `@-sigiled` 变量为数组和 `%-sigiled` 变量为哈希的常见使用情况，当你用 `@` 或 `%` 声明一个变量时，Raku 将它们作为默认类型。也就是说，当你向一个未初始化的 `@-sigiled` 变量赋值时，Raku 会提供一个默认的数组（对于 `%` 和 `Hash` 也是如此）。所以我们可以写成 `my @a = 1, 2` 来创建一个有1和2的数组；或者我们可以写成 `my %h = k => "v"` 来创建一个哈希。但这只是一个默认值--你可以完全自由地绑定任何提供正确接口的类型。

一个需要记住的推论是：这个规则对于提供所需接口类型的类型并不例外--它适用于任何赋值。这使事情变得简单；毕竟，有很多时候我们想要一个 `Buf` 的数组；`Buf` 是位置型的并没有什么区别。这意味着 `my @b = Buf.new` 创建了一个包含一个 `Buf` 的数组（就像 `my @n = 1` 创建了一个包含 1 的数组）。如果我们想让 `@b` 成为一个 `Buf`，我们需要绑定而不是分配： `my @b := Buf.new`。

在这一点上，我们已经涵盖了四种 Raku 所提供的力量。在我们继续前进之前，这里有一个表格，其中有一个总结。

| sigil 	| @ 	     | % 	| & 	| $ |
|:----------|:-----------|:-----|:------|:--|
| Interface | Positional |	Associative | Callable 	| Scalar |
| Default 	| Array 	 | Hash 	    | (none) 	| (none) |
| Iteration | One at a time; fixed order| 	One pair at a time; random order |	Entire container |	Entire container|
| Guarantee | Positional indexing |	Associative indexing |	invokable |	(none) |

3. 实践中的 Raku 符号

为了真正判断它们的力量，让我们在一个更实际的环境中看一下 Raku 的符号图。想象一下，我们正在使用 [FiveThirtyEight](https://fivethirtyeight.com/) 的世界杯预测--特别是，他们对决赛的赛前预测。

![img](https://rakuadventcalendar.files.wordpress.com/2021/12/538_2022-world-cup.png?w=371&h=251)

我们会从哪里开始呢？我们的数据由两个键值对组成。让我们用 Raku 的 [Pair](https://docs.raku.org/type/Pair) 来表示它们。`Argentina => .53`  和  `France => .47`。接下来，我们要将这些对存储到一个变量中。但我们应该使用什么符号呢？

好吧，我们可以不使用任何符号，但这将牺牲掉在 Raku 中与符号有关的所有好处。不，谢谢。或者我们可以使用一个 `&` 符号变量，写成 `my &f = {(Argentina => .53, France => .47)}` 。但这将是一个非常奇怪的--好吧，怪异的--选择。通过使用 `&`，我们得到了一个不需要参数的函数，当被调用时，会返回这两对数据--这似乎比直接使用这两对数据要差一些。我提到使用 `&` 的可能性，只是为了强调这是我们的选择：我们选择了符号（以及语义）。

说完了这两点，让我们来考虑一下三个可行的选项。`@`, `%`, 和 `$`。

使用 `@` 符号可以创建一个包含两个配对的数组；我们可以用 `my @win‑predictions = Argentina => .53, France => .47` 来做这个。这样可以保持配对的顺序，所以如果我们关心顺序的话，这可能是一个不错的选择（也许我们打算按胜率来显示球队的排名？） @-sigiled 数组还可以让我们挨个遍历这些球队。

另外，使用 `%` 符号( `my %win-predictions = Argentina => .53, France => .47` ) 给我们一个以球队名称为键，以预测赔率为值的哈希，这让我们可以通过提供球队名称来访问球队的赔率：例如，`%win-predictions<France>` 返回 .53。如果我们需要访问一个任意球队的获胜赔率，这可能是一种方法（也许我们正在建立一个搜索框，你可以输入一个名字来查看该球队的预测赔率）。`%` 符号的 Hash 仍然可以让我们挨个遍历这些球队，但这次是以随机的顺序。

那 `$` 符号呢？嗯，我们实际上有几个选择。`$` 告诉 Raku（和读者），我们把预测作为一个单独的项（而不是一个集合）。这意味着 `my $win-predictions = Argentina => .53, France => .47` 不是我们想要的语法--因为 `$` 符号的变量总是单个项，这将把 `Argentina => .53` 这对变量分配给 `$win-predictions`，而丢弃第二对。(如果我们这样做了，Raku 会帮助我们警告说我们可能不是故意的）。

为了将这两对组合都存储在 `$win-predictions` 中，我们需要以某种方式将它们分组。例如，我们可以用方括号将它们分组，这样就可以创建一个数组。这两个选项看起来分别是 `my $win-predictions = [Argentina => .53, France => .47]` 和 `my $win-predictions = {Argentina => .53, France => .47}`。

但是等等，如果我们最终在我们的 `$-`符号变量中存储一个数组或哈希，那使用 `$` 与使用 `@` 或 `%` 符号有什么不同？

不同的是，`$` 向 Raku 和读者传达了我们将整个数组/哈希作为一个单独的项来处理--Raku 也应该这样。这有一些影响，最明显的是，在一个 `$` 符号的数组/哈希上迭代，将一次取得整个容器，而不是一次取得一个对。

如果我们把"比赛"看作一个单一的实体（而不是球队-赔率对的集合），这种"项"语义可能最适合我们的心理模型。这样看有很多意义--毕竟，如果不知道我们在谈论他们与阿根廷的比赛，"法国队有 `47%` 的机会获胜"的说法就没有什么意义。如果我们确实使用 `$`-sigiled 变量，那么我们仍然需要决定是使用数组还是哈希。这里的考虑与我们在 `@` 和 `%` 之间的选择基本相同：我们是更关心保存顺序还是按球队名称进行索引？

总而言之，我们可以在三种符号中进行选择。选择 `@` 表示我们正在使用一个有序的 Pair 数组；选择 `%` 表示我们关注键值关系；选择 `$` 表示我们将匹配作为单个项。

而且，至关重要的是，我们选择的符号完全是在本地传达的：每次读者（几周后可能就是我们！）看到带有某个符号的赢家预测时，都会告诉读者他们是在处理一个有序的集合，一个将键与值联系起来的集合，还是一个概念上的单个项。从来不需要滚动到变量定义的地方--而且，正如函数式程序员不断提醒我们的那样，当我们可以不依赖任何远程上下文来理解代码时，会容易得多。

最后，需要注意的是，我们从符号中得到的信息并不是变量的类型：`my @pos = 1,2` 和 `my $scalar = [1,2]` 都创建了数组，如果你（或你的 IDE）询问 `@pos` 或 `$scalar` 的类型，它们都会诚实地报告说它们是数组。而且，正如我们讨论的，`@-` 和 `%-` 符号的变量并不能保证是数组和哈希。"这个变量是什么类型"和"这个变量提供什么接口"这两个问题是正交的：回答一个问题并不能回答另一个问题。所以 Raku 的符号绝对不是"只是一种可以由 IDE 显示的类型信息的编码方式"--它们是一种创建和记录变量接口的方式。

至少在我看来，对于一个单一的字符来说，这已经是相当多的信息了。我非常高兴地得出结论，Raku 的符号传达了有意义的、低背景的信息。总而言之，我相信我们已经看到 Raku 的符号可以相当强大--这还没有提到 Raku 的九个 "twigils"（次要符号）呢！

结论和接下来的步骤

如果你读到这儿了，谢谢你--你显然是我喜欢的那种奇怪的人...除非你跳过结论，天真地希望我能够提供某种有说服力的长话短说(tl;dr) ಠ_ಠ

在这篇文章中，我们已经谈到了一般的符号，并且看到了--即使在非编程背景下--它们也可以成为与读者进行简明沟通的有力工具。我们还看了 Raku 是如何使用符号的，并看到符号让 Rakoons 向 Raku 和我们代码的读者传达我们的变量有哪些接口。

我希望我已经让你相信，深思熟虑地使用符号，可以使交流更容易，代码更可读。在我的理想世界里，我也希望能诱使你仔细看看 Raku。不过，从现实的角度来看，这篇文章并不是真的为了这样做而优化的--尽管符号很酷，但它们可能不会进入我的十大 Raku 功能列表（第7位会让你震惊！）。

但是，即使它们不是我最喜欢的 Raku 功能，我也想谈谈符号--特别是 Raku 的符号--因为它们是语言的一个优势。然而，人们有时会提到兆头，作为他们或其他人避免使用一种语言的原因--这让我感到完全倒退。

所以，无论是 Raku、Bash、Perl、PHP，还是其他任何使用符号的语言，我希望你不要再因为一种语言比其他语言多用了几个 `$` 而放弃它。符号可以是一个强大的工具。根据维基百科，"sigil" 这个词来自拉丁语，意思是"具有神奇力量的小标志"。而且，是的，"神奇的力量"对我来说似乎是正确的。

只是，你知道，不是十级的魔法。

接下来的步骤

既然你已经读到这里了，这里有几个方法可以让你继续前进。

    如果你认为我错了，你可以在 Hacker News 或 Reddit 上告诉我。
    如果这篇文章中对 Raku 的一瞥让你感兴趣，你想了解更多，我推荐 Andrew Shitov 的书《Raku 编程语言完整教程》（在线免费，感谢 Raku 基金会的资助）。《Raku 指南》和《在 Y 分钟内学会 Raku》也很不错。或者加入 libera.chat 上的 #raku 或 #raku-beginners IRC 频道--每个人都非常友好。 我们甚至以某种方式设法使我们的角落保持令人惊讶的友好和帮助）。
    如果你认为我对符号的看法过于乐观或片面，你可能会对我在为这篇文章进行研究时发现的一些最好的批评意见感兴趣。《符号的问题》和《论符号》。
    如果你已经熟悉 Raku ，并希望更深入地了解符号是如何工作/实现的，我强烈推荐 Zoffix Znet 的2017年深度研究和 Elizabeth Mattijsen 的 Raku 会议讲座《符号》。一旦你了解它们，你就会爱上它们。或者看看我的博客，codesections.com/blog，看看即将发表的一篇强有力的后续文章--不管你信不信，我几乎没有触及关于 Raku 中的符号的表面，我很想把我从这篇文章中删掉的几千字的不连贯的废话变成对使符号成为可能的机制的深入探讨。
    最后，如果你想分享任何想法（除了第一条中的橙色网站，我的意思是），或者如果你只是想打个招呼，请随时在 Fosstodon Mastodon 实例、#raku IRC 频道或通过电子邮件与我联系，daniel@codesections.com。
